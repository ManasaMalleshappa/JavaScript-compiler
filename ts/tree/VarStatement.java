
package ts.tree;

import ts.Location;
import ts.tree.visit.TreeVisitor;
import ts.tree.type.*;

/**
 * AST var statement node
 *
 */
public final class VarStatement extends Statement {
	private String name;

	// the following fields will be filled in by the semantic analyzer
	//
	// this variable declaration is nested inside this many functions
	private int functionDepth;
	//
	// Java temp name to be used to represent this variable (if it is
	// not captured by a closure
	private String tempName;
	//
	// is this variable captured by a closure?
	private boolean isCaptured;
	//
	// the type of the variable (might be Unknown, meaning it is either
	// unknown or ambiguous
	private Type type;
	//
	// is the variable declaration redundant?
	private boolean isRedundant;

	/**
	 * Construct a var statement tree node.
	 *
	 * @param loc
	 *            the source code location of the var statement.
	 * @param name
	 *            the name of the identifier being declared.
	 */
	public VarStatement(final Location loc, final String name) {
		super(loc);
		this.name = name;
		this.functionDepth = 0;
		this.tempName = null;
		this.isCaptured = false;
		this.type = null;
		this.isRedundant = false;
	}

	/**
	 * Get the name of the identifier being declared.
	 *
	 * @return the name of the identifier being declared.
	 */
	public String getName() {
		return name;
	}

	/**
	 * Get the function depth of the identifier being declared.
	 *
	 * @return the function depth of the identifier being declared.
	 */
	public int getFunctionDepth() {
		return functionDepth;
	}

	/**
	 * Set the function depth of the identifier being declared.
	 *
	 * @param functionDepth
	 *            the function depth of the identifier being declared.
	 */
	public void setFunctionDepth(int functionDepth) {
		this.functionDepth = functionDepth;
	}

	/**
	 * Get the codegen temp name of the identifier being declared.
	 *
	 * @return the codegen temp name of the identifier being declared.
	 */
	public String getTempName() {
		return tempName;
	}

	/**
	 * Set the codegen temp name of the identifier being declared.
	 *
	 * @param tempName
	 *            the codegen temp name of the identifier being declared.
	 */
	public void setTempName(String tempName) {
		this.tempName = tempName;
	}

	/**
	 * Get the type of the identifier being declared.
	 *
	 * @return the type of the identifier being declared.
	 */
	public Type getType() {
		return type;
	}

	/**
	 * Set the type of the identifier being declared.
	 *
	 * @param type
	 *            the type of the identifier being declared.
	 */
	public void setType(Type type) {
		this.type = type;
	}

	/**
	 * Is the variable captured by a closure?
	 *
	 * @return whether the variable is captured by a closure.
	 */
	public boolean isCaptured() {
		return isCaptured;
	}

	/**
	 * Record that the variable is captured by a closure.
	 *
	 */
	public void setIsCaptured() {
		this.isCaptured = true;
	}

	/**
	 * Is the variable declaration redundant?
	 *
	 * @return whether the variable declaration is redundant.
	 */
	public boolean isRedundant() {
		return isRedundant;
	}

	/**
	 * Record that the variable declaration is redundant.
	 *
	 */
	public void setIsRedundant() {
		this.isRedundant = true;
	}

	/**
	 * Apply a visitor to the node.
	 *
	 * @param visitor
	 *            the visitor to apply.
	 *
	 * @return the value generated by the visitor.
	 */
	@Override
	public <T> T apply(TreeVisitor<T> visitor) {
		return visitor.visit(this);
	}
}
